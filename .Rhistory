for (i in 1:10) {
column_name <- Countries[i]
plot_list_ex_ret[[i]] <- ggplot(annualized_returns_chopped, aes(x = date, y = !!sym(column_name))) +
geom_line() +
theme_minimal() +
labs(x = "Date", y = "Bond Excess Return", title = paste(column_name))+
theme(
axis.title.x = element_text(size = 5),
axis.title.y = element_text(size = 5),
axis.text.x = element_text(size = 4),
axis.text.y = element_text(size = 4),
plot.title = element_text(size = 7)
)
}
grid.arrange(grobs = plot_list_ex_ret, ncol = 2)
annualized_returns_chopped <- annualized_returns %>%
# 1) Pivot to long format
pivot_longer(
cols = -date,
names_to = "Country",
values_to = "AnnReturn"
) %>%
# 2) Arrange by date & group by country
group_by(Country) %>%
arrange(date, .by_group = TRUE) %>%
# 3) Chop values above +500% or below -500% (±5 in decimal), replace w/ NA
mutate(
AnnReturn = if_else(abs(AnnReturn) > 10, NA_real_, AnnReturn)
) %>%
# 4) Fill newly introduced NAs forward, then backward
mutate(
AnnReturn = na.locf(AnnReturn, na.rm = FALSE),          # forward fill
AnnReturn = na.locf(AnnReturn, fromLast = TRUE, na.rm = FALSE) # backward fill
) %>%
ungroup() %>%
# 5) Pivot back to wide format (optional)
pivot_wider(
names_from = "Country",
values_from = "AnnReturn"
)
plot_list_ex_ret<- list()
for (i in 1:10) {
column_name <- Countries[i]
plot_list_ex_ret[[i]] <- ggplot(annualized_returns_chopped, aes(x = date, y = !!sym(column_name))) +
geom_line() +
theme_minimal() +
labs(x = "Date", y = "Bond Excess Return", title = paste(column_name))+
theme(
axis.title.x = element_text(size = 5),
axis.title.y = element_text(size = 5),
axis.text.x = element_text(size = 4),
axis.text.y = element_text(size = 4),
plot.title = element_text(size = 7)
)
}
grid.arrange(grobs = plot_list_ex_ret, ncol = 2)
load("C:/Users/fajka/OneDrive - WU Wien/WU/50_PMP/02_BOND_TM1/TM1_PortfolioStrategies/V7.RData")
ewmaVar2_c_good <- ewmaVar2_c[-length(ewmaVar2_c)]
umve_weights = compute_weights(ewmaVar2_c_i_good, e_e_ret_m)
compute_weights <- function(varcov_matrices, expected_excess_returns) {
# Initialize a list to store weights for each t
p_weights <- list()
# Loop over each time step
for (t in seq_along(varcov_matrices)) {
# Extract the variance-covariance matrix for time t
V_t <- varcov_matrices[[t]]
# Extract the expected excess returns for time t
E_rX_t <- expected_excess_returns[t, ]
# Compute the numerator: V_t^(-1) * E_rX_t
numerator <- solve(V_t) %*% E_rX_t
# Compute the denominator: 1 + E_rX_t' * V_t^(-1) * E_rX_t
denominator <- 1 + t(E_rX_t) %*% solve(V_t) %*% E_rX_t
# Compute the weights for time t
w_t <- numerator / as.numeric(denominator)
# Store the weights for time t
p_weights[[t]] <- w_t
}
return(p_weights)
}
ewmaVar2_c_good <- ewmaVar2_c[-length(ewmaVar2_c)]
umve_weights = compute_weights(ewmaVar2_c_good, e_e_ret_m)
umve_weights
sum(umve_weights[[1]])
View(fwspread_country_c)
View(fwspread_country_c)
View(e_e_ret)
### Expected excess returns
e_e_ret = beta_fsw*fwspread_country_c + beta_val*Value_c
### Expected excess returns
e_e_ret = beta_fsw*fwspread_country_c*100 + beta_val*Value_c
# Function to compute portfolio returns
compute_portfolio_returns <- function(weights_list, excess_returns_matrix) {
# Initialize a vector to store portfolio returns
portfolio_returns <- numeric(length(weights_list))
# Loop over each time t
for (t in seq_along(weights_list)) {
# Extract weights for time t
w_t <- weights_list[[t]]
# Extract excess returns for time t+1
rX_t1 <- excess_returns_matrix[t + 1, -1]  # Exclude the date column
# Ensure dimensions align
if (length(w_t) != length(rX_t1)) {
stop(sprintf("Dimension mismatch at t = %d: weights and returns", t))
}
# Compute the portfolio return
portfolio_returns[t] <- sum(w_t * rX_t1)
}
return(portfolio_returns)
}
compute_portfolio_returns(umve_weights, annualized_returns)
UMVE_port <- compute_portfolio_returns(umve_weights, annualized_returns)
print(UMVE_port)
mean(UMVE_port)
### Constructing the fwspread dataset
fwspread_country = read_excel("C:/Users/Student1.AzureAD/ZZ Vermögensverwaltung GmbH/ISK-Wien - General/ZZ Gruppe/2024/Personal/Tomas/tm1_bonds/Merged_Bonds_FX_p.xlsx")
### Expected excess returns
e_e_ret = beta_fsw*fwspread_country_c + beta_val*Value_c
### Inverting the Variance covariance matrix
ewmaVar2_c <- ewmaVar2[names(ewmaVar2) >= "2000-12"]
### Calculating portfolio weights
e_e_ret_m = as.matrix(e_e_ret)
compute_weights <- function(varcov_matrices, expected_excess_returns) {
# Initialize a list to store weights for each t
p_weights <- list()
# Loop over each time step
for (t in seq_along(varcov_matrices)) {
# Extract the variance-covariance matrix for time t
V_t <- varcov_matrices[[t]]
# Extract the expected excess returns for time t
E_rX_t <- expected_excess_returns[t, ]
# Compute the numerator: V_t^(-1) * E_rX_t
numerator <- solve(V_t) %*% E_rX_t
# Compute the denominator: 1 + E_rX_t' * V_t^(-1) * E_rX_t
denominator <- 1 + t(E_rX_t) %*% solve(V_t) %*% E_rX_t
# Compute the weights for time t
w_t <- numerator / as.numeric(denominator)
# Store the weights for time t
p_weights[[t]] <- w_t
}
return(p_weights)
}
ewmaVar2_c_good <- ewmaVar2_c[-length(ewmaVar2_c)]
umve_weights = compute_weights(ewmaVar2_c_good, e_e_ret_m)
umve_weights
sum(umve_weights[[1]])
### Descriptive statistics on UMVE weights
lapply(umve_weights, summary)
umve_weights_unlist = unlist(umve_weights)
mean_umve = mean(umve_weights_unlist)
median_umve = median(umve_weights_unlist)
std_umve = sd(umve_weights_unlist)
# Function to compute portfolio returns
compute_portfolio_returns <- function(weights_list, excess_returns_matrix) {
# Initialize a vector to store portfolio returns
portfolio_returns <- numeric(length(weights_list))
# Loop over each time t
for (t in seq_along(weights_list)) {
# Extract weights for time t
w_t <- weights_list[[t]]
# Extract excess returns for time t+1
rX_t1 <- excess_returns_matrix[t + 1, -1]  # Exclude the date column
# Ensure dimensions align
if (length(w_t) != length(rX_t1)) {
stop(sprintf("Dimension mismatch at t = %d: weights and returns", t))
}
# Compute the portfolio return
portfolio_returns[t] <- sum(w_t * rX_t1)
}
return(portfolio_returns)
}
UMVE_port <- compute_portfolio_returns(umve_weights, annualized_returns)
print(UMVE_port)
mean(UMVE_port)
plot(UMVE_port, type = "l", col = "blue", xlab = "Time", ylab = "Portfolio Return", main = "UMVE Portfolio Returns")
# cumsum returns plotted
plot(cumsum(UMVE_port), type = "l", col = "blue", xlab = "Time", ylab = "Cumulative Portfolio Return", main = "UMVE Cumulative Portfolio Returns")
# plot the UMW weights
hist(umve_weights_unlist, breaks = 50, col = "blue", xlab = "UMVE Weights", main = "UMVE Weights Distribution")
plot(umve_weights_unlist, type = "l", col = "blue", xlab = "Time", ylab = "UMVE Weights", main = "UMVE Weights over Time")
# Plot the weights of the UMVE portfolio and provide descriptive statistics
# Load the required library
library(ggplot2)
library(reshape2)
# Example data (replace this with your actual weights data)
set.seed(42)
# Load necessary libraries
library(ggplot2)
library(reshape2)
# Convert the list of weights into a data frame
weights_df <- do.call(rbind, umve_weights)
View(umve_weights)
View(umve_weights)
umve_weights[[1]]
View(annualized_returns)
View(annualized_returns)
# Load necessary libraries
library(ggplot2)
library(reshape2)
# Convert the list of weights into a data frame
weights_df <- do.call(rbind, umve_weights)
colnames(weights_df) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
View(weights_df)
# Convert the list of weights into a data frame
weights_df <- do.call(rbind, umve_weights)
colnames(weights_df) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
View(umve_weights)
# Convert the list of weights into a data frame
weights_df <- do.call(rbind, umve_weights)
colnames(weights_df) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
ncol(weights_df)
dim(weights_matrix)
dim(weights_df)
# Convert the list of weights into a data frame
weights_df <- do.call(rbind, umve_weights)
View(weights_df)
# Convert the list of weights into a data frame
weights_matrix <- matrix(unlist(umve_weights), ncol = 10, byrow = TRUE)
View(weights_matrix)
colnames(weights_matrix) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
# Add a date column (assuming you have a sequence of dates corresponding to the weights)
weights_df <- as.data.frame(weights_df)
weights_df$Date <- seq.Date(from = as.Date("2000-12-29"), by = "month", length.out = nrow(weights_df))  # Adjust start date and frequency as needed
# Melt the data for ggplot
weights_melted <- melt(weights_df, id.vars = "Date", variable.name = "Country", value.name = "Weight")
# Create the stacked area plot
ggplot(weights_melted, aes(x = Date, y = Weight, fill = Country)) +
geom_area(alpha = 0.8, size = 0.2, colour = "black") +
scale_fill_manual(values = rainbow(length(unique(weights_melted$Country)))) +  # Assign distinct colors to each country
labs(
title = "Times Series of Portfolio Weights",
x = "Date",
y = "UMVE Portfolio Weights",
fill = "Country"
) +
theme_minimal() +
theme(
text = element_text(size = 12),
legend.position = "bottom"
)
View(weights_melted)
# Convert the list of weights into a data frame
weights_matrix <- matrix(unlist(umve_weights), ncol = 10, byrow = TRUE)
colnames(weights_matrix) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
# Add a date column (assuming you have a sequence of dates corresponding to the weights)
weights_matrix <- as.data.frame(weights_matrix)
weights_matrix$Date <- seq.Date(from = as.Date("2000-12-29"), by = "month", length.out = nrow(weights_df))  # Adjust start date and frequency as needed
# Melt the data for ggplot
weights_melted <- melt(weights_matrix, id.vars = "Date", variable.name = "Country", value.name = "Weight")
# Convert the list of weights into a data frame
weights_matrix <- matrix(unlist(umve_weights), ncol = 10, byrow = TRUE)
colnames(weights_matrix) <- c("AUSTRALIA", "BRITAIN", "CANADA", "GERMANY", "JAPAN",
"NEW ZEALAND", "NORWAY", "SWEDEN", "SWITZERLAND", "UNITED STATES")
# Add a date column (assuming you have a sequence of dates corresponding to the weights)
weights_matrix <- as.data.frame(weights_matrix)
weights_matrix$Date <- seq.Date(from = as.Date("2000-12-29"), by = "month", length.out = nrow(weights_matrix))  # Adjust start date and frequency as needed
# Melt the data for ggplot
weights_melted <- melt(weights_matrix, id.vars = "Date", variable.name = "Country", value.name = "Weight")
# Create the stacked area plot
ggplot(weights_melted, aes(x = Date, y = Weight, fill = Country)) +
geom_area(alpha = 0.8, size = 0.2, colour = "black") +
scale_fill_manual(values = rainbow(length(unique(weights_melted$Country)))) +  # Assign distinct colors to each country
labs(
title = "Times Series of Portfolio Weights",
x = "Date",
y = "UMVE Portfolio Weights",
fill = "Country"
) +
theme_minimal() +
theme(
text = element_text(size = 12),
legend.position = "bottom"
)
################### Descriptive Statistics ####################
# Portfolio weights unlisted for analysis
umve_weights_unlist <- unlist(umve_weights)
# Descriptive statistics for weights
mean_weights <- mean(umve_weights_unlist) * 100  # Convert to %
median_weights <- median(umve_weights_unlist) * 100  # Convert to %
std_weights <- sd(umve_weights_unlist) * 100  # Convert to %
min_weights <- min(umve_weights_unlist) * 100
max_weights <- max(umve_weights_unlist) * 100
positive_weights <- sum(umve_weights_unlist > 0) / length(umve_weights_unlist) * 100  # Percentage of positive weights
negative_weights <- sum(umve_weights_unlist < 0) / length(umve_weights_unlist) * 100  # Percentage of negative weights
weight_turnover <- mean(abs(diff(umve_weights_unlist))) * 100  # Turnover: change in weights over time
# Summary Table for Portfolio Weights
weights_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Min (in %)", "Max (in %)",
"Positive Weights (in %)", "Negative Weights (in %)",
"Average Turnover (in %)"),
Value = c(mean_weights, median_weights, std_weights,
min_weights, max_weights,
positive_weights, negative_weights,
weight_turnover)
)
print(weights_summary)
# Descriptive statistics for portfolio returns
mean_returns <- mean(UMVE_port) * 100  # Convert to %
median_returns <- median(UMVE_port) * 100  # Convert to %
std_returns <- sd(UMVE_port) * 100  # Convert to %
sharpe_ratio <- mean(UMVE_port) / sd(UMVE_port)  # Assuming risk-free rate is 0
max_drawdown <- max(cummax(cumsum(UMVE_port)) - cumsum(UMVE_port)) * 100  # Maximum drawdown
# Turnover for portfolio returns
portfolio_turnover <- mean(abs(diff(UMVE_port))) * 100  # Average turnover in returns
# Summary Table for Portfolio Returns
returns_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Sharpe Ratio", "Maximum Drawdown (in %)",
"Average Turnover (in %)"),
Value = c(mean_returns, median_returns, std_returns,
sharpe_ratio, max_drawdown, portfolio_turnover)
)
print(returns_summary)
# Portfolio Weights Distribution
hist(umve_weights_unlist * 100, breaks = 50, col = "blue",
xlab = "Portfolio Weights (in %)", main = "Distribution of Portfolio Weights")
# Portfolio Returns over Time
plot(UMVE_port * 100, type = "l", col = "blue",
xlab = "Time", ylab = "Portfolio Return (in %)", main = "UMVE Portfolio Returns Over Time")
# Cumulative Portfolio Returns
plot(cumsum(UMVE_port) * 100, type = "l", col = "green",
xlab = "Time", ylab = "Cumulative Return (in %)", main = "Cumulative Portfolio Returns")
# Load the stargazer package
library(stargazer)
# Create the weights_summary table
weights_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Min (in %)", "Max (in %)",
"Positive Weights (in %)", "Negative Weights (in %)",
"Average Turnover (in %)"),
Value = c(mean_weights, median_weights, std_weights,
min_weights, max_weights,
positive_weights, negative_weights,
weight_turnover)
)
# Format the table using stargazer
stargazer(weights_summary, type = "text", summary = FALSE, rownames = FALSE,
title = "Descriptive Statistics for Portfolio Weights",
digits = 2)
print(weights_summary)
# Create the returns_summary table
returns_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Sharpe Ratio", "Maximum Drawdown (in %)",
"Average Turnover (in %)"),
Value = c(mean_returns, median_returns, std_returns,
sharpe_ratio, max_drawdown, portfolio_turnover)
)
# Format the table using stargazer
stargazer(returns_summary, type = "text", summary = FALSE, rownames = FALSE,
title = "Descriptive Statistics for Portfolio Returns",
digits = 2)
library(RColorBrewer)
# Choose a softer color palette (e.g., "Set3")
palette_colors <- brewer.pal(n = length(unique(weights_melted$Country)), "Set3")
# Create the plot with the new palette
ggplot(weights_melted, aes(x = Date, y = Weight, fill = Country)) +
geom_area(alpha = 0.8, size = 0.2, colour = "black") +
scale_fill_manual(values = palette_colors) +  # Use the softer "Set3" palette
labs(
title = "Time Series of Portfolio Weights",
x = "Date",
y = "UMVE Portfolio Weights",
fill = "Country"
) +
theme_minimal() +
theme(
text = element_text(size = 12),
legend.position = "bottom"
)
# Function to compute portfolio returns
compute_portfolio_returns <- function(weights_list, excess_returns_matrix) {
# Initialize a vector to store portfolio returns
portfolio_returns <- numeric(length(weights_list))
# Loop over each time t
for (t in seq_along(weights_list)) {
# Extract weights for time t
w_t <- weights_list[[t]]
# Extract excess returns for time t+1
rX_t1 <- excess_returns_matrix[t + 1, -1]  # Exclude the date column
# Ensure dimensions align
if (length(w_t) != length(rX_t1)) {
stop(sprintf("Dimension mismatch at t = %d: weights and returns", t))
}
# Compute the portfolio return
portfolio_returns[t] <- sum(w_t * rX_t1)
}
return(portfolio_returns)
}
UMVE_port <- compute_portfolio_returns(umve_weights, annualized_returns)
print(UMVE_port)
mean(UMVE_port)
plot(UMVE_port, type = "l", col = "blue", xlab = "Time", ylab = "Portfolio Return", main = "UMVE Portfolio Returns")
# cumsum returns plotted
plot(cumsum(UMVE_port), type = "l", col = "blue", xlab = "Time", ylab = "Cumulative Portfolio Return", main = "UMVE Cumulative Portfolio Returns")
# Portfolio weights unlisted for analysis
umve_weights_unlist <- unlist(umve_weights)
# Descriptive statistics for weights
mean_weights <- mean(umve_weights_unlist) * 100  # Convert to %
median_weights <- median(umve_weights_unlist) * 100  # Convert to %
std_weights <- sd(umve_weights_unlist) * 100  # Convert to %
min_weights <- min(umve_weights_unlist) * 100
max_weights <- max(umve_weights_unlist) * 100
positive_weights <- sum(umve_weights_unlist > 0) / length(umve_weights_unlist) * 100  # Percentage of positive weights
negative_weights <- sum(umve_weights_unlist < 0) / length(umve_weights_unlist) * 100  # Percentage of negative weights
weight_turnover <- mean(abs(diff(umve_weights_unlist))) * 100  # Turnover: change in weights over time
# Load the stargazer package
library(stargazer)
# Create the weights_summary table
weights_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Min (in %)", "Max (in %)",
"Positive Weights (in %)", "Negative Weights (in %)",
"Average Turnover (in %)"),
Value = c(mean_weights, median_weights, std_weights,
min_weights, max_weights,
positive_weights, negative_weights,
weight_turnover)
)
# Format the table using stargazer
stargazer(weights_summary, type = "text", summary = FALSE, rownames = FALSE,
title = "Descriptive Statistics for Portfolio Weights",
digits = 2)
# Descriptive statistics for portfolio returns
mean_returns <- mean(UMVE_port) * 100  # Convert to %
median_returns <- median(UMVE_port) * 100  # Convert to %
std_returns <- sd(UMVE_port) * 100  # Convert to %
sharpe_ratio <- mean(UMVE_port) / sd(UMVE_port)  # Assuming risk-free rate is 0
max_drawdown <- max(cummax(cumsum(UMVE_port)) - cumsum(UMVE_port)) * 100  # Maximum drawdown
# Turnover for portfolio returns
portfolio_turnover <- mean(abs(diff(UMVE_port))) * 100  # Average turnover in returns
# Create the returns_summary table
returns_summary <- data.frame(
Metric = c("Mean (in %)", "Median (in %)", "Std. Dev. (in %)",
"Sharpe Ratio", "Maximum Drawdown (in %)",
"Average Turnover (in %)"),
Value = c(mean_returns, median_returns, std_returns,
sharpe_ratio, max_drawdown, portfolio_turnover)
)
# Format the table using stargazer
stargazer(returns_summary, type = "text", summary = FALSE, rownames = FALSE,
title = "Descriptive Statistics for Portfolio Returns",
digits = 2)
# Portfolio Weights Distribution
hist(umve_weights_unlist * 100, breaks = 50, col = "blue",
xlab = "Portfolio Weights (in %)", main = "Distribution of Portfolio Weights")
# Portfolio Returns over Time
plot(UMVE_port * 100, type = "l", col = "blue",
xlab = "Time", ylab = "Portfolio Return (in %)", main = "UMVE Portfolio Returns Over Time")
# Cumulative Portfolio Returns
plot(cumsum(UMVE_port) * 100, type = "l", col = "green",
xlab = "Time", ylab = "Cumulative Return (in %)", main = "Cumulative Portfolio Returns")
# Cumulative Portfolio Returns
plot(cumsum(UMVE_port) * 100, type = "l", col = "darkblue",
xlab = "Time", ylab = "Cumulative Return (in %)", main = "Cumulative Portfolio Returns")
save.image("C:/Users/fajka/OneDrive - WU Wien/WU/50_PMP/02_BOND_TM1/TM1_PortfolioStrategies/V7.RData")
# Define the dimensions for Full HD (16:9 aspect ratio)
width <- 1920
height <- 1080
# Save the Time Series Plot of Portfolio Weights
png("Time_Series_Portfolio_Weights.png", width = width, height = height, res = 150)
ggplot(weights_melted, aes(x = Date, y = Weight, fill = Country)) +
geom_area(alpha = 0.8, size = 0.2, colour = "black") +
scale_fill_manual(values = brewer.pal(n = length(unique(weights_melted$Country)), "Set3")) +
labs(
title = "Time Series of Portfolio Weights",
x = "Date",
y = "UMVE Portfolio Weights",
fill = "Country"
) +
theme_minimal() +
theme(
text = element_text(size = 12),
legend.position = "bottom"
)
dev.off()
# Save the Portfolio Weights Distribution Plot
png("Portfolio_Weights_Distribution.png", width = width, height = height, res = 150)
hist(umve_weights_unlist * 100, breaks = 50, col = "blue",
xlab = "Portfolio Weights (in %)", main = "Distribution of Portfolio Weights")
dev.off()
# Save the Portfolio Returns Over Time Plot
png("Portfolio_Returns_Over_Time.png", width = width, height = height, res = 150)
plot(UMVE_port * 100, type = "l", col = "blue",
xlab = "Time", ylab = "Portfolio Return (in %)", main = "UMVE Portfolio Returns Over Time")
dev.off()
# Save the Cumulative Portfolio Returns Plot
png("Cumulative_Portfolio_Returns.png", width = width, height = height, res = 150)
plot(cumsum(UMVE_port) * 100, type = "l", col = "darkblue",
xlab = "Time", ylab = "Cumulative Return (in %)", main = "Cumulative Portfolio Returns")
dev.off()
# Save the Descriptive Statistics Tables
library(gridExtra)
library(grid)
# Convert weights_summary and returns_summary into tables for plotting
weights_table <- tableGrob(weights_summary, rows = NULL)
returns_table <- tableGrob(returns_summary, rows = NULL)
# Save weights_summary to a PNG
png("Weights_Descriptive_Statistics.png", width = width, height = height, res = 150)
grid.newpage()
grid.draw(weights_table)
dev.off()
# Save returns_summary to a PNG
png("Returns_Descriptive_Statistics.png", width = width, height = height, res = 150)
grid.newpage()
grid.draw(returns_table)
dev.off()
